{"version":3,"sources":["StreamlitPlotlyEventsComponent.tsx","index.tsx"],"names":["StreamlitPlotlyEventsComponent","StreamlitComponentBase","constructor","arguments","state","data","layout","clickedPoints","x","y","z","measureMode","measurePoints","measureLineWidth","render","plot_obj","JSON","parse","this","props","args","override_height","override_width","plotClickedPoint","clickedPointSize","click_event","select_event","hover_event","with_z","get_relayout","Streamlit","setFrameHeight","React","createElement","Plot","onClick","plotlyEventHandler","undefined","onSelected","onHover","onRelayout","relayoutEventHandler","style","width","height","className","plot_clicked_point","clicked_point_size","currentClickedPoint","points","previousClickedPointState","needToUpdate","console","log","setState","measurePlot","getPoint","curveNumber","pointNumber","clickPointPlot","mode","marker","color","showlegend","type","name","text","hovertemplate","concat","toFixed","size","length","push","createMeasureLine","lines","updatePlotState","forEach","arrayItem","pointIndex","measurePointsX","map","filter","flat","measurePointsY","measurePointsZ","dx","parseFloat","distances","dy","dz","dxyz","dxy","dxz","dyz","setComponentValue","stringify","Math","abs","sqrt","pow","line","plot_data","eventData","eye","cameraPostion","cameraLayout","componentDidMount","measure_mode","measure_line_width","uirevision","withStreamlitConnection","ReactDOM","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.47564b5d.chunk.js","sourcesContent":["import {\n  Streamlit,\n  StreamlitComponentBase,\n  withStreamlitConnection,\n} from \"streamlit-component-lib\";\nimport React, { ReactNode } from \"react\";\nimport Plot from 'react-plotly.js';\n\ninterface MyState {\n  data: any[];\n  layout: any;\n  clickedPoints: { x: number; y: number; z: number };\n  measureMode: boolean;\n  measurePoints: any[];\n  measureLineWidth: number;\n  camera?: number[]\n}\n\nclass StreamlitPlotlyEventsComponent extends StreamlitComponentBase<MyState> {\n  // Create state for points\n  state: MyState = {\n    data: [],\n    layout: {},\n    clickedPoints: { x: 0.0, y: 0.0, z: 0.0 },\n    measureMode: false,\n    measurePoints: [],\n    measureLineWidth: 0.0\n  };\n\n  // init the component state when first starting it\n  // make the layout constant across updates\n  componentDidMount() {\n    let plot_obj = JSON.parse(this.props.args[\"plot_obj\"])\n    let measure_mode: boolean = this.props.args['measure_mode']\n    let measure_line_width: number = this.props.args['measure_line_width']\n\n    plot_obj.layout.uirevision = 'true'\n    console.log('current plot layout: ', plot_obj.layout)\n    this.setState({\n      data: plot_obj.data,\n      layout: plot_obj.layout,\n      clickedPoints: {\n        x: 0,\n        y: 0,\n        z: 0,\n      },\n      measureMode: measure_mode,\n      measurePoints: [],\n      measureLineWidth: measure_line_width\n    });\n  }\n\n  public render = (): ReactNode => {\n    // Pull Plotly object from args and parse\n    var plot_obj = JSON.parse(this.props.args[\"plot_obj\"]);\n    const override_height = this.props.args[\"override_height\"];\n    const override_width = this.props.args[\"override_width\"];\n    const plotClickedPoint: boolean = this.props.args['plot_clicked_point']\n    const measureLineWidth: number = this.props.args['measure_line_width']\n    /*Get the current point size of the chart we are plotting to draw the extra clicked point\n      with respect to the scale of the plotted points\n    */\n    const clickedPointSize: number = this.props.args['clicked_point_size']\n    // Event booleans\n    const click_event = this.props.args[\"click_event\"];\n    const select_event = this.props.args[\"select_event\"];\n    const hover_event = this.props.args[\"hover_event\"];\n    const with_z = this.props.args[\"with_z\"];\n    const get_relayout = this.props.args['get_relayout']\n\n    Streamlit.setFrameHeight(override_height);\n    return (\n      <Plot\n        data={this.state.data}\n        layout={this.state.layout}\n        // config={this.state.config}\n        // frames={this.state.frames}\n        onClick={click_event ? this.plotlyEventHandler(with_z, plot_obj, plotClickedPoint, clickedPointSize) : undefined}\n        onSelected={select_event ? this.plotlyEventHandler(with_z) : undefined}\n        onHover={hover_event ? this.plotlyEventHandler(with_z) : undefined}\n        onRelayout={get_relayout? this.relayoutEventHandler: undefined}\n        style={{ width: override_width, height: override_height }}\n        className=\"stPlotlyChart\"\n      />\n    );\n  };\n\n  /** Click handler for plot. */\n  private plotlyEventHandler = (with_z: boolean, plot_obj?: any, plot_clicked_point?: boolean, clicked_point_size?: number) => {\n\n    // console.log('pressed on point')\n    return (data: any) => {\n      const getCircularReplacer = () => {\n        const seen = new WeakSet();\n        return (key: string, value: any) => {\n          if (typeof value === \"object\" && value !== null) {\n            if (seen.has(value)) {\n              return '[Circular]';\n            }\n            seen.add(value);\n          }\n          return value;\n        };\n      };\n      // JSON.parse(data.points[0])\n      // console.log('pressed on point', JSON.stringify(data.points[0], getCircularReplacer(), 2))\n      // console.log('current plot object', plot_obj)\n      let currentClickedPoint = data.points[0]\n      let previousClickedPointState = this.state.clickedPoints\n      let needToUpdate = false\n      if (currentClickedPoint.x !== previousClickedPointState.x ||\n        currentClickedPoint.y !== previousClickedPointState.y ||\n        currentClickedPoint.z !== previousClickedPointState.z) {\n        console.log('clicked point x diff')\n        needToUpdate = true\n        this.setState({\n          clickedPoints: {\n            x: currentClickedPoint.x,\n            y: currentClickedPoint.y,\n            z: currentClickedPoint.z,\n          }\n        })\n      } else {\n        needToUpdate = false\n      }\n\n      // measurePlot is used within the lifetime of this function\n      let measurePlot: any = {}\n      if (plot_clicked_point && needToUpdate === true) {\n\n        const getPoint = data.points[0]\n        const traceIndex = getPoint.curveNumber\n        const pointIndex = getPoint.pointNumber\n        console.log(`current getPoint:`, getPoint)\n        // console.log('current point number:', pointIndex)\n        // console.log('current trace number', traceIndex)\n        // console.log('current colors: ', plot_obj.data[traceIndex].marker.color[pointIndex])\n        // console.log('current data for plot', this.state.data)\n\n        // console.log('plot_obj', plot_obj)\n        // create a point object to add to our current plot to indicate the clicked point\n        interface newPoint {\n          x: number[];\n          y: number[];\n          z?: number[];\n          mode: string;\n          marker: {\n            color: string;\n            size?: number;\n          };\n          showlegend: boolean;\n          type: string;\n          name: string,\n          text: string[],\n          hovertemplate: string,\n        }\n\n        let clickPointPlot: newPoint = {\n          x: [getPoint.x],\n          y: [getPoint.y],\n          z: [getPoint.z],\n          mode: 'markers',\n          marker: {\n            color: 'red',\n            // size: clicked_point_size === 0.0 && undefined? 5.0: clicked_point_size*1.5,\n          },\n          showlegend: false,\n          type: getPoint.z !== undefined ? 'scatter3d' : 'scatter',\n          name: 'Clicked Point',\n          text: ['Clicked Point'],\n          hovertemplate: '<b>%{text}</b><br>'\n            + `<b>x: ${getPoint.x.toFixed(3)}</b><br>`\n            + `<b>y: ${getPoint.y.toFixed(3)}</b><br>`\n            + `<b>z: ${getPoint.z.toFixed(3)}</b><extra></extra>`\n\n        };\n\n        if (clicked_point_size !== undefined) {\n          clickPointPlot.marker.size = clicked_point_size\n        }\n        else {\n          clickPointPlot.marker.size = 5.0\n        }\n\n\n        // calculate measure points and plot them on the chart\n        if (this.state.measureMode === true) {\n          // let measurePoints = this.state.measurePoints\n          // measurePoints.push(clickPointPlot)\n          if (this.state.measurePoints.length >= 2) {\n            this.state.measurePoints.length = 0;\n            this.state.measurePoints.push(clickPointPlot)\n          }\n          else {\n            this.state.measurePoints.push(clickPointPlot)\n          }\n          // calculate measure points when the length is 2 then plot on the chart\n          if (this.state.measurePoints.length === 2) {\n            const measurePoints = this.state.measurePoints\n\n            measurePlot = this.createMeasureLine(measurePoints)\n            measurePoints.push(...measurePlot.lines)\n          }\n\n          console.log('measure points: ', this.state.measurePoints)\n        }\n        // update the plot \n        // append new trace of clicked point here then update plot state\n        if (this.state.measureMode === true) {\n          plot_obj.data.push(...this.state.measurePoints)\n        }\n        else {\n          plot_obj.data.push(clickPointPlot)\n        }\n        console.log('plotting using: ', plot_obj)\n        this.updatePlotState(plot_obj)\n      }\n\n      // Build array of points to return\n      if (needToUpdate === true) {\n        let clickedPoints: Array<any> = [];\n        data.points.forEach(function (arrayItem: any) {\n          if (with_z) {\n            clickedPoints.push({\n              x: arrayItem.x,\n              y: arrayItem.y,\n              z: arrayItem.z,\n              curveNumber: arrayItem.curveNumber,\n              pointNumber: arrayItem.pointNumber,\n              pointIndex: arrayItem.pointIndex\n            });\n          } else {\n            clickedPoints.push({\n              x: arrayItem.x,\n              y: arrayItem.y,\n              curveNumber: arrayItem.curveNumber,\n              pointNumber: arrayItem.pointNumber,\n              pointIndex: arrayItem.pointIndex\n            });\n          }\n        });\n\n        // Add measure points to return when in measure mode\n        if (this.state.measureMode === true) {\n          console.log('measurepoint length: ', this.state.measurePoints.length)\n          clickedPoints.push({\n            // x: this.state.measurePoints.map(pointX => pointX.x)\n            measurePointsX: this.state.measurePoints.map(points => points.x).filter(measurePointsX => measurePointsX.length === 1).flat(),\n            measurePointsY: this.state.measurePoints.map(points => points.y).filter(measurePointsY => measurePointsY.length === 1).flat(),\n            measurePointsZ: this.state.measurePoints.map(points => points.z).filter(measurePointsZ => measurePointsZ.length === 1).flat(),\n            dx: this.state.measurePoints.length === 1 ? 0 : parseFloat(measurePlot.distances[0].toFixed(3)),\n            dy: this.state.measurePoints.length === 1 ? 0 : parseFloat(measurePlot.distances[1].toFixed(3)),\n            dz: this.state.measurePoints.length === 1 ? 0 : parseFloat(measurePlot.distances[2].toFixed(3)),\n            dxyz: this.state.measurePoints.length === 1 ? 0 : parseFloat(measurePlot.distances[3].toFixed(3)),\n            dxy: this.state.measurePoints.length === 1 ? 0 : parseFloat(measurePlot.distances[4].toFixed(3)),\n            dxz: this.state.measurePoints.length === 1 ? 0 : parseFloat(measurePlot.distances[5].toFixed(3)),\n            dyz: this.state.measurePoints.length === 1 ? 0 : parseFloat(measurePlot.distances[6].toFixed(3)),\n          })\n        }\n\n\n        // Return array as JSON to Streamlit\n        Streamlit.setComponentValue(JSON.stringify(clickedPoints));\n      }\n\n    };\n  };\n  private createMeasureLine = (measurePoints: any) => {\n    const dx = Math.abs(measurePoints[1].x - measurePoints[0].x)\n    const dy = Math.abs(measurePoints[1].y - measurePoints[0].y)\n    const dz = Math.abs(measurePoints[1].z - measurePoints[0].z)\n    const dxyz = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2) + Math.pow(dz, 2))\n\n    const dxy = Math.sqrt(dx * dx + dy * dy);\n    const dxz = Math.sqrt(dx * dx + dz * dz);\n    const dyz = Math.sqrt(dy * dy + dz * dz);\n\n    // xyz measure line\n    const linexyz = {\n      x: [...measurePoints[0].x, ...measurePoints[1].x],\n      y: [...measurePoints[0].y, ...measurePoints[1].y],\n      z: [...measurePoints[0].z, ...measurePoints[1].z],\n      mode: 'lines',\n      line: {\n        color: 'purple',\n        width: this.state.measureLineWidth,\n      },\n      type: 'scatter3d',\n      name: 'Distance',\n      text: [\"Point 1\", \"Point 2\"],\n      hovertemplate: \"<b>%{text}</b><br>\"\n        + `<b>Measured distance: ${dxyz.toFixed(3)}m</b><br>`\n        + `<b>ΔXY: ${dxy.toFixed(3)}</b><br>`\n        + `<b>ΔXZ: ${dxz.toFixed(3)}</b><br>`\n        + `<b>ΔYZ: ${dyz.toFixed(3)}</b><extra></extra>`\n    };\n\n    // x measure line\n    const linex = {\n      x: [...measurePoints[0].x, ...measurePoints[1].x],\n      y: [...measurePoints[0].y, ...measurePoints[0].y],\n      z: [...measurePoints[0].z, ...measurePoints[0].z],\n      mode: 'lines',\n      line: {\n        color: 'red',\n        width: this.state.measureLineWidth,\n      },\n      type: 'scatter3d',\n      name: 'Distance X',\n      text: [\"Point 1\", \"Point 2\"],\n      hovertemplate: `<b>Measured distance X: ${dx.toFixed(3)}m</b><extra></extra>`\n    };\n\n    // xz measure line\n    const liney = {\n      x: [...measurePoints[1].x, ...measurePoints[1].x],\n      y: [...measurePoints[0].y, ...measurePoints[1].y],\n      z: [...measurePoints[0].z, ...measurePoints[0].z],\n      mode: 'lines',\n      line: {\n        color: 'green',\n        width: this.state.measureLineWidth,\n      },\n      type: 'scatter3d',\n      name: 'Distance Y',\n      text: [\"Point 1\", \"Point 2\"],\n      hovertemplate: `<b>Measured distance Y: ${dy.toFixed(3)}m</b><extra></extra>`\n    };\n\n    // z meassure line\n    const linez = {\n      x: [...measurePoints[1].x, ...measurePoints[1].x],\n      y: [...measurePoints[1].y, ...measurePoints[1].y],\n      z: [...measurePoints[0].z, ...measurePoints[1].z],\n      mode: 'lines',\n      line: {\n        color: 'blue',\n        width: 4,\n      },\n      type: 'scatter3d',\n      name: 'Distance Z',\n      text: [\"Point 1\", \"Point 2\"],\n      hovertemplate: `<b>Measured distance X: ${dz.toFixed(3)}m</b><extra></extra>`\n    };\n    return (\n      {\n        lines: [linexyz, linex, liney, linez],\n        distances: [dx, dy, dz, dxyz, dxy, dxz, dyz]\n      }\n    )\n  }\n  private updatePlotState = (plot_data: any): void => {\n    this.setState({\n      data: plot_data.data,\n      // layout: plot_data.layout,\n      // config: this.state.config,\n      // frames: this.state.frames,\n\n    })\n  }\n  private relayoutEventHandler = (eventData: any): void => {\n    interface cameraPostionObject {\n      cameraLayout: {\n        x: number\n        y: number\n        z: number\n      }\n    }\n    console.log('relayout callback')\n    if (eventData && eventData['scene.camera']) {\n      const eye = eventData['scene.camera'].eye\n      console.log('current eye', eye)\n      const cameraPostion: cameraPostionObject = {\n        cameraLayout: {\n          x: eye.x,\n          y: eye.y,\n          z: eye.z\n        }\n\n      }\n      Streamlit.setComponentValue(JSON.stringify(cameraPostion))\n    } \n  }\n}\n\nexport default withStreamlitConnection(StreamlitPlotlyEventsComponent);","import React from \"react\"\nimport ReactDOM from \"react-dom\"\nimport StreamlitPlotlyEventsComponent from \"./StreamlitPlotlyEventsComponent\"\n\nReactDOM.render(\n  <React.StrictMode>\n    <StreamlitPlotlyEventsComponent />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n)\n"],"sourceRoot":""}